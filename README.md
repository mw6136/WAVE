# WAVE : Methods for Solving the Wave Equation
### Comparing Numerical Methods on Cylindrical Wave Equation Solver Performance
<p align="left">
<img src="https://github.com/mw6136/WAVE/assets/144184708/d6cf7824-2713-4758-9624-795f0be29dc5" width="60%">
</p>

## A Model of Surface Deformation with the Cylindrical Wave Equation
For a small deformation of any planar circular elastic material, the surface deformation, $\phi$, satisfies the wave equation in plane-polar coordinates

$$\frac{\partial^2 \phi}{\partial t^2} = c^2 \left[ \frac{1}{r} \frac{\partial}{\partial r} \left(r \frac{\partial \phi}{\partial r}\right) + \frac{1}{r^2} \frac{\partial^2 \phi}{\partial \theta^2} \right]$$

where the driving force of the wave motion for a material initially at rest can be specified through the boundary and initial conditions. Seeking to model waves on the surface of the fluid generated by the motion of the walls, we choose the following boundary and initial conditions.

Boundary Conditions: \
$\phi(r=R, \theta, t) = A \cos(\omega t) \cos (\theta)$ \
$\phi(r=0, \theta, t) \rightarrow \textrm{finite}$ \
$\phi(r, \theta + 2\pi, t) = \phi(r, \theta, t)$ \

Initial Conditions: \
$\phi(r, \theta, t=0) = 0$ \
$\partial \phi/ \partial t (r, \theta, t=0) = 0$

<p align="left">
<img src="https://github.com/mw6136/WAVE/assets/144184708/b3378325-87dc-4669-991d-cb421a41f216" width="60%">
</p>



## Running the code
### Hierarchy and Structure
The analytical solution is computed with infinite series summations using ``Matlab`` in the ``WAVE/Analytical_Solution/code/`` directory.

The base ``Python`` script ``run_cases.py``, can be run with ``python ./Numerical_Methods/run_cases.py`` when in the `/WAVE/` directory. This script calls and executes the functions for each of the numerical methods implemented to solve the scalar wave equation.

Numerical methods\
``discrete.py``: Finite difference discretization with forward difference in $r$ and central differences in $\theta$ and time.\
``fft_solver.py``: 2-D discrete fast Fourier transforms with forward Euler time progression.\
``fwd_euler.py``: Second-order time and spatial differentiations.\
``RK2.py``: Second-order time and spatial differentiations at weighted average half-timestep.

Comparison data from the analytical solution is obtained from ``getting_analytical_data.py`` (you can also run ``polar_analytical_solution.py`` to get new analytical data, but this is not recommended since it takes an extremely long time)

### Slurm Submission
The Princeton high-performance CPU clusters ([TIGER](https://researchcomputing.princeton.edu/systems/tiger) or [ADROIT](https://researchcomputing.princeton.edu/systems/adroit)) may be used by submitting a job with Slurm Workload Manager. Below is a sample Slurm script for running the Python code using a Conda environment:
```
#!/bin/bash
#SBATCH --job-name=myjob         # create a short name for your job
#SBATCH --nodes=1                # node count
#SBATCH --ntasks=1               # total number of tasks across all nodes
#SBATCH --cpus-per-task=1        # cpu-cores per task (>1 if multi-threaded tasks)
#SBATCH --mem-per-cpu=4G         # memory per cpu-core (4G is default)
#SBATCH --time=01:00:00          # total run time limit (HH:MM:SS)
#SBATCH --mail-type=begin        # send email when job begins
#SBATCH --mail-type=end          # send email when job ends
#SBATCH --mail-user=<YourNetID>@princeton.edu

module purge
module load anaconda3/2024.2
conda activate pytools-env

python run_cases.py
```
The first line of the Slurm script specifies the Unix shell to be used. This is followed by a series of ``#SBATCH`` directives which set the resource requirements and other parameters of the job. The script above requests 1 CPU-core and 4 GB of memory for 1 hour of run time. The necessary changes to the environment are made by loading the anaconda3/<version> environment module and activating a particular Conda environment. The execution of the Python script is specified in the final line.

A job script named ``job.slurm`` is submitted to the Slurm scheduler with the ``sbatch`` command:

``$ sbatch job.slurm``

## Numerical Implementation (and citation)
The numerical approaches implemented in WAVE include Fourier spectral methods [1,2], finite-difference discretization [3], forward Euler, and 2nd-order Runge-Kutta. The analytical solution was developed using a method of separation of variables and eigenfunction expansion.

[1] B. Costa. Spectral methods for partial differential equations. *CUBO, A Mathematical Journal*, 6(4):1–32, Dec 2004.

[2] M. Frigo and S. G. Johnson. The design and implementation of FFTW3. *Proceedings of the IEEE*, 93(2):216–231, 2005. Special issue on “Program Generation, Optimization, and Platform Adaptation”.

[3] K. Kanos. Discretizing the wave equation in polar coordinates. Physics Stack Exchange, 2014. URL: ``https://physics.stackexchange.com/q/112906``.
